title: struct内存占用  
date: 2015-07-5 15:30:16  
categories: Technology  
tags: [C++]
---
## 大端存储小端存储

#### 问题: 32位小端机，用栈传递参数，下面程序的输出为:

 ```c++
int main() {
    long long a = 1, b = 2, c = 3;
    printf("%d %d %d\n", a, b, c);
}
 ```
解析：long long是8个字节，int是4个字节，printf函数是最后一个参数先入栈，即c先入栈，然后b，a入栈，结果如下：  
<!-- more -->

header 1 | header 2
---|---
row 1 col 1 | row 1 col 2
row 2 col 1 | row 2 col 2

 | 低地址 | mid | 高地址 |
 | ---- | :----: | ----: |
 | 0x01 00 00 00 0x00 00 00 00 | 0x02 00 00 00 0x00 00 00 00 | 0x03 00 00 00 0x00 00 00 00 |

 从低地址开始去三个int输出，结果为1，0，2。

#### 大端存储和小端存储  

 **大端存储**是指数据对高字节存储在低地址中，而字数据的低字节存储在高地址位中。**小端存储**是指数据对高字节存储在高地址中，数据低字节存储到低地址中。例如，32bit宽度数0x12345678在Litten-endian模式CPU内存的存放方式为(假设从地址0x4000开始存放)：

 | 内存地址 | 0x4000 | 0x4001 | 0x4002 | 0x4003 |
 | ---- | :----: | :----: | :----: | :----: |
 | 存放内容 | 0x78 | 0x56 | 0x34 | 0x12 |

在Big-endian模式CPU内存中的存放方式为：  

 | 内存地址 | 0x4000 | 0x4001 | 0x4002 | 0x4003 |
 | ---- | :----: | :----: | :----: | :----: |
 | 存放内容 | 0x12 | 0x34 | 0x56 | 0x78 |

## 存储类型影响位域成员的存放

如果定义低数据成员中包含`bit`位域，则有以下存放规则：  
 1. 低字节都存放到低地址位；
 2. 大端模式首先为字节段高的`bit`位分配空间，小端模式首先为字段低的`bit`位分配空间；  
 3. 大端模式首先存放地址的高`bit`位，小端模式首先存放地址的低`bit`位。  
 
举例如下：  

```C++
struct {
    short bit1:4;
    short bit2:9;
    short bit3:3;
};
```

大端模式下在内存中存放的形式如下：  

 | pos1 | pos2 | pos3 | pos4 |
 | ---- | :----: | :----: | :----: |
 | bit1(4位) | bit2(高4位) | bit2(低5位) | bit3(3位) |

小端模式下内存中存放形式如下：  

 | pos1 | pos2 | pos3 | pos4 |
 | ---- | :----: | :----: | :----: |
 | bit2(低4位) | bit2(高4位) | bit3(3位) | bit2(高4位) |

## `sizeof`

`sizeof`是一个单目运算符，不是函数，作用是给出操作数的存储大小。  
 1. `sizeof`计算发生在编译期，可以用作常亮表达式，并且会忽略各种运算，比如`sizeof(++a)`，`++`不执行。  
 2. `sizeof`用于数据类型是必须加括号，`sizeof(type)`。  
 3. `sizeof`与`strlen()`不同的是`sizeof`计算数据占用的字节空间，会将`\0`计算在内，而`strlen()`不会。  

## `struct`空间计算

`struct`空间计算遵循两个原则：
 1. 整体空间是占用空间最大成员所占字节数的整数倍。  
 2. 数据对齐 －－ 内存安结构题成员的先后顺序排列，当排到该成员变量时，其前面已摆放的空间大小必须是该成员类型大小的整数倍，如果不够则补齐，依次后推，`Linux`下，如果某成员类型所占字节数超过4，则前面已摆放的空间大小为4的倍数即可，不够的情况下补齐。

当`struct`中含有`struct`时，空间计算原则需按如下进行：  
 1. 整体空间时子结构体与父结构体中占用空间最大成员所占字节数的整数倍；`Linux`32位环境下，若成员类型占用超过4，则前面摆放的空间是4的倍数即可，不够则补齐。  
 2. 数据对齐 －－ 父结构体内存按结构体成员的先后排列，当排列到子结构体成员时，其前面已经摆放的空间大小必须是该子结构题成员中最大类型大小的整数倍，如果不够则补齐。  
 3. 含位域的结构体中，实际所在字节就是其所占有的字节数，比如`int a:3`所占用的字节数位1。
 4. 另外，枚举当作整型处理。
